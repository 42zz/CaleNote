# CaleNote 製品版 仕様設計書（パフォーマンス最適化版）

**バージョン**: 1.0-draft  
**対象**: iOS 17+ / SwiftUI + SwiftData  
**目的**: "全予定が見える"体験を維持しつつ、タイムラインと検索を常にサクサク動作させる。同期や大量データ取得はUIから切り離し、差分反映のみで整合を保つ。

---

## 目次

1. [定義](#1-定義)
2. [非機能要件（性能）](#2-非機能要件性能)
3. [データ設計（責務分離）](#3-データ設計責務分離)
4. [エントリー同一性とリンク方式](#4-エントリー同一性とリンク方式)
5. [同期設計（差分パイプライン）](#5-同期設計差分パイプライン)
6. [タイムライン機能（軽量表示の設計）](#6-タイムライン機能軽量表示の設計)
7. [検索機能（段階検索）](#7-検索機能段階検索)
8. [編集と反映（ローカル即反映）](#8-編集と反映ローカル即反映)
9. [状態管理（State Store）](#9-状態管理state-store)
10. [機能仕様](#10-機能仕様)
11. [画面仕様](#11-画面仕様)
12. [UI/UX仕様](#12-uiux仕様)
13. [技術仕様](#13-技術仕様)
14. [実装状況](#14-実装状況)
15. [障害・復旧方針](#15-障害復旧方針)
16. [実装ガイド（仕様からの拘束事項）](#16-実装ガイド仕様からの拘束事項)

---

## 1. 定義

本アプリにおける「エントリー」は、アプリのタイムライン上に表示可能な単位を指す。エントリーはデータ起源により2種に分類されるが、UIでは区別しない。

* **ローカル作成エントリー**: アプリで作成されたジャーナル。作成時にGoogle Calendarイベントへ射影される（後述のリンク方式による）。
* **Google由来エントリー**: Google Calendarから取得したイベント。必要に応じてジャーナル化（リンク）できる。

「全予定を表示」は「全期間のイベントが、ユーザーが到達した日付範囲について欠落なく表示できる」ことを意味し、初回起動で全期間を即時に端末へ取り込むことは要件に含めない。全期間の取り込みは段階的に達成される。

---

## 2. 非機能要件（性能）

UI操作に対して以下を満たすことを最優先とする。

* **タイムライン初期表示**: 1秒以内に"今日周辺"が表示される
* **タイムラインスクロール**: 60fps目標、セル再生成を抑制
* **検索入力への反応**: 200ms以内に候補が出始める（段階検索で良い）
* **同期処理**: UIスレッドを占有しない（UI更新は差分適用のみ）
* **データ増加時も、通常操作（閲覧・検索・編集）はO(差分)で処理される設計にする**

このため、**UIが参照するデータは必ず"UI専用のインデックス"から取得**し、Rawデータを直接フェッチして整形する実装は禁止する。

---

## 3. データ設計（責務分離）

本設計の中核は、データを3系統に分離することである。

### 3.1 Raw Event Store（同期の正規化ストア）

Google Calendar APIのイベントを、カレンダーID + イベントIDで一意に保持する。これは「同期の正」として扱うが、UIは直接参照しない。

保持するフィールドは、再生成・差分判定・詳細表示に必要な最小限とする。タイトル、本文、開始終了、終日、更新日時、ステータス、extendedProperties.private などを含む。

ローカル作成ジャーナルについても、同様にGoogleイベントに射影された結果のeventIdを保持し、同一のRaw Storeへ統合する。

**実装上の対応**:
- **推奨**: 新規に`RawCalendarEvent`モデルを定義し、既存の`CachedCalendarEvent`と`ArchivedCalendarEvent`を段階的に移行
- **移行期間**: 既存2モデルを残す場合でも、Raw Storeとして統合して扱い、短期/長期の区別は「取得レンジ管理」で表現する
- **重要**: UIや検索は必ずIndexを参照し、Raw Storeを直接フェッチしてはならない

### 3.2 Timeline UI Index（表示専用インデックス）

タイムライン描画のための"行"テーブル。UIが参照するのはこれのみ。Raw Storeから生成され、差分で更新される。

ここに入れる情報は「一覧セルを描画するのに必要な最小限」に限定し、本文全文や巨大データは持たない。必要ならスニペット（先頭N文字程度）だけを保持する。

このインデックスは **再生成可能なキャッシュ**であり、破損時はRaw Storeから再構築できること。

**実装上の対応**:
- `TimelineItem`をSwiftDataモデル化し、`TimelineRowIndex`として永続化
- 日付キー（YYYYMMDD）をインデックスとして持つ
- セクション設計: `dateKey(YYYYMMDD)` をキーに、その日のrowId列を参照できる構造

**主キーとソートキー**:
- **`rowId`**: `base64url(calendarId) + ":" + base64url(eventId)` 形式の安定ID
  - 正式フォーマット: `base64url(calendarId) + ":" + base64url(eventId)`
  - base64urlエンコーディングにより、calendarIdに`:`が含まれていても衝突しない
  - ジャーナルもGoogleイベント化するのでeventIdで統一できる
  - SwiftDataの`@Attribute(.unique)`で一意性を保証
- **`sortKeyPrimary`**: 開始日時（UTCエポックミリ秒、Int64）
  - GoogleのdateTimeは秒精度でも、ローカル生成はミリ秒精度を持つ
  - 同秒衝突を避けるためミリ秒を使用
- **`sortKeySecondary`**: `stableHash(eventId)`（UInt64）
  - eventIdの安定ハッシュ値（文字列比較を避ける）
  - 実装では `(sortKeyPrimary DESC, sortKeySecondary DESC)` で並べる
  - 比較が軽く、SwiftUIのdiffも暴れにくい
- **`dateKey`**: ローカルTZ基準（Asia/Tokyo固定）のYYYYMMDD形式整数
  - セクション分けと日付検索に使用
  - 例: 2024年12月25日 → `20241225`

### 3.3 Search Index（検索専用インデックス）

検索はタイムラインと独立した索引を持つ。全文検索を毎回走らせない。検索対象はタイトル・タグ・本文スニペット（必要なら）をトークン化し、逆引きできる構造で保持する。

検索結果の表示は Timeline UI Index の rowId を参照して行い、Raw Storeを直接検索して一覧に流し込むことは禁止する。

**実装上の対応**:
- `SearchIndex`モデルを新規定義
- タグ検索は `#tag -> rowId` の逆引きを持つ
- トークン化された検索キーワードからrowIdを高速取得

**SearchIndexの実体モデル（製品版v1）**:
SwiftDataで以下のモデルを定義する：

```swift
@Model
final class TagIndex {
    @Attribute(.unique) var tag: String  // "#tag"形式（#を含む）
    var rowIds: [String]  // rowId配列（上限: 2000件）
}

@Model
final class PrefixTitleIndex {
    @Attribute(.unique) var prefix: String  // タイトルの先頭1〜3文字（正規化後）
    var rowIds: [String]  // rowId配列（上限: 2000件）
}
```

**RelatedIndexの実体モデル**:
```swift
@Model
final class RelatedKeyIndex {
    @Attribute(.unique) var key: String  // "monthDay:1223" または "weekday:1:52" または "holiday:JP:NEW_YEAR"
    var rowIds: [String]  // rowId配列（上限: 2000件）
}
```

**配列更新の制約**:
- rowId配列の上限は2000件
- 上限超過時は古いものを落とす（FIFO）
  - 新しいrowIdを追加する際、配列が2000件を超える場合は最も古いrowIdを削除
  - 古さの判定は、Raw Event Storeの`updatedAt`または`cachedAt`を使用
- 更新コストを考慮し、差分更新のみを許可（全件再構築は禁止）
- 配列の更新はバッチ化し、UI更新はまとめて適用する（小刻み更新でレンダリングを荒らさない）

---

## 4. エントリー同一性とリンク方式

ローカル作成エントリー（ジャーナル）とGoogleイベントを紐付けるため、Googleイベントの `extendedProperties.private` にアプリ識別子とjournalIdを保存する。これにより、Google側で編集・移動が行われても同一性を追跡できる。

このJSON構造は**確定仕様**である：

```json
extendedProperties.private = {
  "app": "calenote",
  "schema": "1",
  "journalId": "<UUID文字列>"
}
```

UI上では「予定」「ジャーナル」の種別は表示上区別しないが、編集権限や同期方針の判定にはこのリンク情報を用いる。

---

## 5. 同期設計（差分パイプライン）

同期処理は、UIとは別レーンで動作し、結果は必ず"差分適用"としてIndexへ反映する。同期には2種類のレンジ同期を設ける。

### 5.1 近傍レンジ同期（表示のための同期）

初回起動時および通常利用で重要なのは"今日周辺が速い"ことなので、まず近傍期間（例: 過去30日〜未来30日）を優先的に取り込む。

この同期は timeMin/timeMax による範囲取得で構築され、取得したイベントはRaw Storeへ正規化保存され、その差分だけTimeline UI IndexとSearch Indexへ反映される。

### 5.2 拡張レンジ同期（全期間に向けた段階取り込み）

ユーザーのスクロール到達や日付ジャンプなどのトリガーに応じて、必要な過去・未来の範囲を追加で取得する。これにより、ユーザー体験としては「どこへ行っても予定が出る」を満たす。

全期間の完全取り込みを目指す場合も、同様にレンジを段階的に拡張していく。完走したレンジは「取り込み済み」として管理され、再実行を避ける。

### 5.3 増分同期（syncToken）

**syncToken運用への移行条件**:
- カレンダー単位で「完全な同期状態」が成立した場合に限り、以後はsyncTokenで差分のみを取得する増分運用へ移行する
- 「完全な同期状態」の定義: **到達済みレンジについて取り込みが完了している**状態
  - 近傍レンジ（過去30日〜未来30日）の取り込みが完了している
  - ユーザーがスクロールや日付ジャンプで到達した拡張レンジの取り込みが完了している
  - 未到達レンジがあるのは当然であり、未取得レンジがないことは要件に含めない
- 全期間（2000年〜未来1年）の完全取り込みは必須ではない

**取得済みレンジ管理**:
- State Storeに「取得済みレンジ集合」を保持する
- レンジ表現: **月単位チャンク**（例: "2024-01" から "2024-12" まで）
  - 日単位は細かすぎ、年単位は粗すぎ。月単位が無難
- **月チャンクの境界**: Asia/Tokyoの月で定義する
  - 月チャンクは **Asia/Tokyoの月**で定義する（dateKeyと同じタイムゾーン）
  - timeMin/timeMaxは **その月の00:00 JST ～ 翌月00:00 JST** をUTC変換してAPIに投げる
  - これにより「取得済みのはずなのに、その月末のイベントが抜ける」問題を防止
- レンジ完走時はState Storeに記録し、再実行を避ける

**syncTokenの保持場所**:
- State Store（UserDefaultsまたは専用軽量テーブル）でカレンダーごとに保持
- SwiftDataの巨大モデルには混ぜない

**syncToken運用**:
- syncToken運用中は、更新・削除（cancelled含む）を必ず反映し、Raw Storeと両Indexを差分更新する
- syncToken期限切れ（410）を受けた場合は、そのカレンダーのみフル同期（レンジ完走）にフォールバックし、トークンを再確立する

**繰り返しイベント（singleEvents）の扱い**:
- レンジ同期では`singleEvents=true`を指定し、繰り返しイベントを展開して取得する
- 展開されたイベントは個別のイベントとしてRaw Storeに保存する
- 元の繰り返しイベント定義は保持しない（展開後のイベントのみを扱う）

**展開の上限と方針**:
- 展開は **取得レンジ内に限定**（レンジ外の繰り返しは展開しない）
- **未来側の拡張レンジ同期の上限**: 未来は+1年まで（無限未来を取りに行くと繰り返しが終わらない）
- 取り込み済みレンジ管理と一体にして、**展開結果の再生成を許容**する
  - Index再構築時と同様に、Raw Storeから展開結果を再生成できる設計にする
  - これにより「繰り返しで端末が膨らみ続ける」事故を防止

### 5.4 レート制限とエラーハンドリング

- `SyncRateLimiter`により、5秒間隔で同期を制限
- **指数バックオフ + ジッター**: HTTP 429（Too Many Requests）またはHTTP 403で`rateLimitExceeded`/`userRateLimitExceeded`を検出した場合、自動リトライ
  - 最大リトライ回数: 5回
  - 最大待機時間: 60秒
  - 計算式: `delay = min(baseDelay * 2^attempt + jitter, maxWaitTime)`
  - ジッター: `random(0..<0.5) * exponentialDelay`（サンダリングハード防止）

### 5.5 同期失敗のCrashlytics送信

同期失敗（ネットワーク、認証、410/429、パース失敗など）を検知したら、Crashlyticsに送信（`SyncErrorReporter`）。送信情報はプライバシー保護を徹底（ユーザーコンテンツは送信しない、カレンダーIDはハッシュ化）。

---

## 6. タイムライン機能（軽量表示の設計）

### 6.1 表示データの取得

タイムライン画面は、Timeline UI Indexからのみ読み出す。Raw Storeからの直接フェッチ、複数モデル結合、表示のたびの全件ソートは禁止する。

### 6.2 セクション設計

日付セクションを中心としたIndexを持つ。具体的には `dateKey(YYYYMMDD)` をキーに、その日のrowId列を参照できる構造を用意する。表示は「セクション一覧」→「セクション内行」の順で、必要分だけ描画する。

### 6.3 ページネーションとウィンドウ制御

タイムラインは日付キー基準で双方向に拡張ロードする。UIメモリ制御のため、表示ウィンドウ上限（例: 600行）を超えた場合は、スクロール方向と逆側の**Timeline View Window**（画面が現在保持している行IDの範囲）を破棄する。

**重要**: 破棄するのは **Timeline View Window（非永続）** であり、**Timeline UI Index（永続）** を削除してはならない。Timeline UI Indexは端末に存在する"全行"の索引であり、検索結果や日付ジャンプで再表示する際に必要である。

Raw Storeも削除してはならない。Raw Storeは検索・復元・整合性維持に必要なため。

### 6.4 初期フォーカス機能

- 初回表示時に「今日セクション」に自動スクロール
- 上へスクロールすると未来日付（明日以降）へ、下へスクロールすると過去日付（前日以前）へ自然に移動
- 今日セクションが存在しない場合でも空セクションを生成してフォーカス可能
- 検索中は自動フォーカスを無効化（検索結果の先頭表示を維持）

### 6.5 日付セクションの強調表示

- **昨日**: 「昨日 (YYYY年MM月DD日)」形式で表示、アクセントカラーで強調
- **今日**: 「今日 (YYYY年MM月DD日)」形式で表示、アクセントカラーで強調
- **明日**: 「明日 (YYYY年MM月DD日)」形式で表示、アクセントカラーで強調

---

## 7. 検索機能（段階検索）

検索は「すぐ反応し、徐々に精度が上がる」を正とする。入力に対して、まずSearch Indexの軽量条件（タイトル・タグ・スニペット）で候補rowIdを即時返し、必要に応じて詳細スコアリングを遅延実行して結果を差し替える。

検索結果の一覧表示は Timeline UI Index を参照して描画し、タップ時にのみRaw Storeを読んで詳細を表示する。

### 7.1 検索の2段階実装（製品版v1）

製品版v1では、検索は次の2段のみに固定する。

* **第1段（200ms以内）**: `title` と `#tag` の逆引き（超高速）
  - タイトル: prefix一致（入力文字列で始まる）
  - タグ: `#tag -> rowId` の逆引き、O(1)に近い速度
* **第2段（遅延実行）**: `snippet` の部分一致（必要なら）
  - 本文スニペット（先頭N文字、タグ除去後）から部分一致検索

**日本語の完全検索は製品版v1では実装しない**。トークン化やn-gramは実装が複雑になり、パフォーマンス要件を満たせない可能性が高い。

### 7.2 正規化ルール

製品版v1では、パフォーマンスを壊さずに最低限の救済を入れる。

* **大文字小文字**: 区別しない（英数字）
* **全角半角**: 統一する（英数字のみ。日本語は現状維持）
* **ひらがな・カタカナ**: 統一しない（現状維持）
* **長音・小書き**: 無視する（例: 「カフェ」と「カフェー」は同一視）
* **濁点**: 統一しない（現状維持）
* **記号**: 検索対象から除外（`#`タグは除く）
* **スペース・区切り**: 連続空白を1つに正規化（例: "a  b" → "a b"）

これらは索引構造を複雑にせずに実装できる。

### 7.3 スニペット生成

スニペットはRaw Storeの`description`から生成する。タグ除去後の本文の先頭N文字（例: 100文字）を保持する。

---

## 8. 編集と反映（ローカル即反映）

編集の体感速度を最優先し、編集操作は次の二段階で処理する。

1. **ローカル即時反映**: Raw StoreとTimeline UI Index、Search Indexを先に更新し、UIを即座に更新する。
2. **リモート反映**: Google Calendar APIへのinsert/updateは非同期で実行する。失敗時は「同期待ち」状態をState Storeに記録し、UIにバッジ等で反映する。

「同期待ち」「同期中」「同期失敗」「競合」などの状態はキャッシュではなくStateであり、SwiftDataの巨大モデルに混ぜず、専用の軽量ストアで管理する。

---

## 9. 状態管理（State Store）

以下は永続キャッシュではなく、アプリの動作状態である。

* カレンダーごとの同期状態（初回レンジ完走状況、syncToken確立有無）
* 同期待ちキュー（再送対象）
* 競合フラグと解決待ち状態
* 拡張レンジ同期の進捗とキャンセル状態
* 取得済みレンジ集合（月単位チャンク、例: ["2024-01", "2024-02", ...]）
* カレンダーごとのsyncToken（増分同期用）

これらはUserDefaultsまたは専用軽量テーブルで保持し、UIは状態を購読するだけにする。状態変化があっても、タイムラインの全再構築を誘発しない設計にする。

---

## 10. 機能仕様

### 10.1 ジャーナル機能

#### 10.1.1 エントリの構成要素

| 項目 | 必須 | 説明 |
|------|------|------|
| タイトル | 任意 | 短い見出し |
| 本文 | 任意 | メインのテキスト。ハッシュタグ対応 |
| 日時 | 自動 | 作成日時（手動変更可） |
| カラー | 任意 | カラーパレットから選択（デフォルト: ミュートブルー） |
| 場所 | 任意 | 位置情報または手入力（未実装） |
| 写真 | 任意 | 複数枚添付可（未実装） |

#### 10.1.2 ハッシュタグ機能

**基本方針**
- タグは `#tag` 形式で本文中に記述
- Google Calendar側には **description に本文 + 改行 + タグ** を保存
- タグは独立したデータ構造として Google Calendar には持たせない

**アプリ内での扱い**
- 保存・更新時に本文から `#tag` をパース（`TagExtractor`）
- タグは SwiftData 内でインデックス化（エントリとの関連のみ保持）
- 全期間のタグ一覧は作成しない

**表示・UI**
- 表示するタグは「最近使われたタグ」のみ
- 最近の定義: 同期対象期間内の`JournalEntry`と有効なカレンダー（`isEnabled == true`）のRaw Event Storeでの使用頻度・直近使用日時（Search Indexから取得）
- カレンダー側で`description`が編集された場合、同期でキャッシュが更新されるとタグ統計に自動反映
- `JournalEntry`と紐付いているイベントは重複カウントを避けるため除外
- タグ一覧は最大20件程度を表示

**検索**
- 検索バーに `#tag` を入力するとタグ検索として機能
- タグ一覧からの選択は「最近使ったタグ」に限定

### 10.2 タイムライン表示

#### 10.2.1 基本仕様
- **逆時系列**で表示（新しいエントリが上、古いものが下）
- Googleカレンダーの予定とジャーナルを統合表示
- **予定とジャーナルは完全に統一されたカードデザインで表示**（区別しない）
- カードの背景色はユーザーが選択したカラーパレットから適用
- カードのアイコンは、設定でカレンダーごとに選択したアイコンパレットから適用
- 日付区切りを表示
- **時間表示**: 時間指定イベントは時刻を表示、終日イベントは「終日」と表示

**注意**: タイムライン表示の詳細は[6. タイムライン機能（軽量表示の設計）](#6-タイムライン機能軽量表示の設計)を参照。

### 10.3 検索機能

- ツールバーの左上に検索アイコン（🔍）を配置
- 検索アイコンをタップすると検索バーがドロワー形式で表示される
- フリーテキスト検索（タイトル、本文、ハッシュタグ）
- 検索バーに `#tag` を入力するとタグ検索として機能
- 検索結果はタイムライン形式で表示
- タグ一覧からの選択は「最近使ったタグ」に限定（最大10件程度）

**注意**: 検索機能の詳細は[7. 検索機能（段階検索）](#7-検索機能段階検索)を参照。

### 10.4 カレンダー機能

- カレンダーボタンタップでカレンダーモーダル/シートを表示（未実装）
- 月表示カレンダー（未実装）
- **ジャーナルがある日にドットマーカー表示**（未実装）
- 日付タップでその日のタイムライン位置にスクロール/遷移（未実装）

### 10.5 初期オンボーディングフロー

#### 10.5.1 表示判定
`RootView`が以下の条件をチェックし、全て満たさない場合はオンボーディングを表示:
- 認証トークンが有効（`auth.user != nil`）
- `CachedCalendar`が存在する
- 少なくとも1件`isEnabled == true`のカレンダーがある

#### 10.5.2 ステップ1: Google Sign-In
- Google Sign-Inボタンを中央に配置
- サインイン成功後、カレンダー一覧の初回同期を実行（`CalendarListSyncService`）
- 同期完了後、自動で次ステップへ遷移
- エラー時はメッセージ表示＆再試行可能

#### 10.5.3 ステップ2: カレンダー選択
- `CachedCalendar`一覧を表示（primaryを先頭に）
- 各カレンダーにトグル（`isEnabled`）を配置
- 初期値: primaryカレンダーを自動的にON（ない場合は先頭）
- 「続ける」ボタン: `isEnabled == true`が1件以上で有効化
- 完了時に`JournalWriteSettings`を自動設定（primaryまたは先頭の有効カレンダー）
- **完了時に選択されたカレンダーの拡張レンジ同期を自動開始**（近傍レンジ同期後、バックグラウンドで段階的に拡張）

### 10.6 関連するエントリー機能

エントリー詳細画面（ジャーナル詳細・予定詳細のどちらでも）に、「関連エントリー」セクションを表示する。関連エントリーは必ずSearch/Related専用インデックスから取得する。

#### 10.6.1 検索条件
以下の3つの条件でマッチするエントリーを検索する（設定で有効/無効を切り替え可能、デフォルト: 同日のみON）：

1. **同じ日（MMDD一致）**: 同じ月日（例: 12月23日）の過去・未来のエントリーを表示
2. **同じ週の同じ曜日**: ISO週番号と曜日が一致するエントリーを表示（過去10年 + 未来10年）
3. **同じ祝日**: 同じ祝日（例: 元日）の過去・未来のエントリーを表示

#### 10.6.2 インデックス要件

関連エントリー検索のために、以下のインデックスフィールドが必要：

**保持場所（決定）**:
- **`monthDayKey (MMDD)`**: Raw Event Storeに保持（同期時に計算）
- **`weekdayKey`**: Raw Event Storeに保持（同期時に計算）
- **`weekOfYearKey`**: Raw Event Storeに保持（同期時に計算）
- **`holidayId`**: Raw Event Storeに保持（同期時に計算）
- **`startDayKey (YYYYMMDD)`**: Raw Event Storeに保持（既存）

**検索フロー**:
1. Related検索はSearch/Related専用インデックス（rowId集合）で返す
2. 表示はTimelineRowIndex（UI）経由で行う
3. Raw Event Storeを直接検索してはならない

**インデックスフィールドの詳細**:
* `startDayKey (YYYYMMDD)`: 日付キー（既存）
* `monthDayKey (MMDD)`: 同日検索用（例: 1223）
* `weekdayKey`: 曜日（0=日曜、1=月曜...）
* `weekOfYearKey`: ISO週番号（同週同曜検索用）
* `holidayId`: 祝日ID（例: "JP:NEW_YEAR"、祝日を扱う場合のみ）

これらのインデックスは同期時に自動計算・保存される。

#### 10.6.3 除外条件
- **同じ年月日のエントリーは除外**: 同じ日付（年・月・日が全て一致）のエントリーは関連エントリーに含めない
- **同じ年のエントリーは除外**: 各検索条件で、対象日と同じ年のエントリーは除外

#### 10.6.4 表示上限

関連エントリーの表示件数は上限を設ける。各検索条件（同日・同週同曜・同祝日）ごとに最大N件（例: 10件）まで表示し、それ以上は「他N件」として表示する。

#### 10.6.5 表示形式
- **年でグルーピング**: 関連エントリーは年ごとにグループ化して表示
- **年ヘッダー**: 「2021年　4年前」形式で表示（年を主、相対年を副として表示）
- **各エントリー行**:
  - **タイトル**: エントリーのタイトル
  - **日付**: 必ず表示
    - 終日イベント: `YYYY/MM/DD`形式のみ
    - 時間指定イベント: `YYYY/MM/DD  HH:mm`形式（開始時刻）
  - **一致理由バッジ**: 「同日」「同週同曜」「同祝日」のバッジを表示（複数条件に一致する場合は複数表示）
- **ソート順**: 年ごとに降順（新しい年から）、同一年内では絶対距離が近い順

### 10.7 競合解決機能

#### 10.7.1 競合検知
ローカルとGoogle Calendar両方でジャーナルが変更された場合に競合を検知する。

**検知条件**:
- `linkedEventUpdatedAt`が存在する（既にカレンダーと同期済み）
- `entry.updatedAt > calendarUpdatedAt`（ローカルの方が新しい）
- 差分が30秒以上（タイムスタンプのずれによる誤検知を防ぐ）

**競合時の動作**:
- `hasConflict = true`を設定
- カレンダー版のスナップショットを保存（title, body, updatedAt, eventDate）
- 同期ステータスに競合カウントを表示
- タイムライン上にオレンジの三角バッジを表示

#### 10.7.2 競合解決UI
- **JournalDetailView**: 競合状態の場合、メタデータセクションに警告表示、「競合を解決」ボタンを表示（オレンジ）
- **ConflictResolutionView（モーダル）**: ローカル版とカレンダー版を並べて表示、各版の表示内容: タイトル、本文、更新日時、イベント日時、「この版を使う」ボタンで解決方法を選択

**解決方法**:
- **useLocal**: ローカル版を採用し、カレンダーに再送信（`needsCalendarSync = true`）
- **useRemote**: カレンダー版を採用し、ローカルを上書き

**解決後**:
- 競合フラグをクリア（`hasConflict = false`、スナップショットも削除）
- タイムライン上のバッジが消える

### 10.8 同期状態バッジ表示

#### 10.8.1 タイムライン上のバッジ表示
**表示位置**: ジャーナルカードの時刻の右側

**バッジの種類** (優先順位: 同期中 → 競合 → 同期失敗 → 同期済み):
- **同期中バッジ** (同期処理実行中):
  - アイコン: 青い回転アイコン（`arrow.triangle.2.circlepath`、回転アニメーション付き）
  - 意味: カレンダーへの同期処理が進行中
  - タップ動作: なし

- **競合バッジ** (`hasConflict == true`):
  - アイコン: オレンジの三角形（`exclamationmark.triangle.fill`）
  - 意味: ローカルとカレンダーの両方が更新されている
  - タップ動作: 詳細画面に遷移（NavigationLinkの通常動作）

- **同期失敗バッジ** (`needsCalendarSync == true`):
  - アイコン: 黄色の円形感嘆符（`exclamationmark.circle.fill`）
  - 意味: カレンダーへの同期が失敗している
  - タップ動作: 確認アラート表示 → 「再送」で個別再送実行

- **同期済み**: バッジなし（何も表示しない）

#### 10.8.2 個別再送機能
1. タイムライン上の同期失敗バッジをタップ
2. 確認アラート表示: 「「タイトル」をカレンダーに再送します。」
3. 「再送」ボタンをタップ → バックグラウンドで`JournalCalendarSyncService.syncOne()`実行
4. 成功時: バッジが消える、ステータスに「再送成功」表示
5. 失敗時: エラーアラート表示

#### 10.8.3 設定画面の「同期待ち」セクション
- 同期待ちのジャーナル件数（`needsCalendarSync == true`）
- **「まとめて再送」ボタン**: 全ての同期待ちジャーナルを一括再送
- **エントリプレビュー**: 最初の5件を表示（タイトル、日付、黄色の感嘆符アイコン、5件以上ある場合「他N件」と表示）
- **空状態**: 「同期待ちのジャーナルはありません」とグレー表示

---

## 11. 画面仕様

### 11.1 オンボーディング画面

#### 11.1.1 ステップ1: Google Sign-In画面
- ロゴ・タイトルエリア: カレンダーアイコン、アプリ名、説明文
- Google Sign-Inボタン: 中央配置、タップでサインイン開始
- ローディング表示: サインイン中・カレンダー同期中はProgressViewを表示
- エラーメッセージ: サインイン失敗時に表示

#### 11.1.2 ステップ2: カレンダー選択画面
- ヘッダー: カレンダーアイコン、タイトル、説明文
- カレンダー一覧: 各カレンダーにトグル（`isEnabled`）を配置、primaryを先頭に表示
- 「続ける」ボタン: `isEnabled == true`が1件以上で有効化
- エラーメッセージ: カレンダー選択エラー時に表示

### 11.2 メイン画面（TimelineView）

#### 11.2.1 構成要素
- 検索アイコン（ツールバー左上）
- カレンダーボタン（ツールバー右上、未実装）
- 新規作成ボタン（ツールバー右上）
- タイムライン（逆時系列、日付区切りあり）
- 同期ステータスインジケーター（右下に表示）
- カスタムタブバー（下部）

#### 11.2.2 インタラクション
- 検索アイコンタップ → 検索バーがドロワー形式で表示、キーボード表示、検索実行
- カレンダーボタンタップ → カレンダーシート表示（未実装）
- 予定カードタップ → 予定詳細（読み取りのみ）
- ジャーナルカードタップ → ジャーナル詳細
- FABタップ → 新規作成画面
- 下スクロール → 過去のエントリを読み込み
- pull-to-refresh → 手動同期実行

#### 11.2.3 同期ステータスインジケーター
- 右下に控えめなステータスアイコンを表示（idle / syncing / success / error）
- 成功時は1.5秒後に自動的にフェードアウト
- エラー時はタップで再試行可能
- アイコンをタップすると詳細情報を展開表示
- 画面を遮らない非侵襲的なUI

### 11.3 ジャーナル作成/編集画面（JournalEditorView）

#### 11.3.1 構成要素
- 閉じるボタン（左上）
- 保存ボタン（右上）
- 書き込み先カレンダー表示（タップで変更可能）
  - カレンダーアイコンと名前を表示
  - タップでカレンダー選択シートを表示
  - 既存エントリの場合は`linkedCalendarId`を更新
  - 新規エントリの場合は選択したカレンダーに保存
- タイトル入力欄
- 本文入力欄
- カラー選択（カラーパレットから選択、デフォルト: ミュートブルー）
- 場所（デフォルト設定に応じて自動入力、未実装）
- 写真追加ボタン（未実装）
- 日時表示/変更

#### 11.3.2 イベント時間設定
- エントリー作成時にカレンダーに登録するエントリーの時間を設定可能
- 設定画面で指定（1〜480分、5分刻み、デフォルト30分）
- イベントの開始時刻は`JournalEntry.eventDate`、終了時刻は開始時刻 + 設定された時間（分）

### 11.4 設定画面（SettingsView）

#### 11.4.1 構成要素
- Google連携: ログイン/ログアウト、ログイン成功後は自動的にカレンダー一覧を同期
- 表示するカレンダー: カレンダー一覧表示（カラーチップとアイコン付き）、カレンダー名をタップでカレンダー設定画面に遷移、表示状態をインジケーター（✓）で表示、カレンダー一覧の再同期ボタン
- ジャーナル設定: エントリー作成時にカレンダーに登録するエントリーの時間を設定（1〜480分、5分刻み、デフォルト30分）
- 同期待ち: `needsCalendarSync == true`のジャーナルを一覧表示、まとめて再送ボタン
- 同期設定: 同期対象期間の設定（過去/未来の日数、デフォルト: 30日）
- 関連する過去の表示設定: 同じ日/同じ週の同じ曜日/同じ祝日のON/OFF切り替え
- 拡張レンジ同期: 進捗表示、キャンセル機能
- 開発者向けツール（隠し機能）: バージョン情報を7回タップで有効化

#### 11.4.2 カレンダー設定画面（CalendarSettingsView）
各カレンダーの設定は、カレンダー名をタップして開くカレンダー設定画面で行う：
- カレンダー情報: カレンダー名と種類（メイン）を表示
- 表示設定: カレンダーの表示ON/OFFを切り替え（最後の1つはOFF不可、ONにすると自動的に拡張レンジ同期が開始される）
- 書き込み先: このカレンダーをデフォルトの書き込み先に設定/解除
- 色: 25色のパレットから選択（グリッドレイアウト、5x5）、選択中の色は太いボーダーと白いチェックマークで強調表示

### 11.5 エントリー詳細画面

#### 11.5.1 統一された画面構造
3つの詳細画面（`JournalDetailView`、`CalendarEventDetailView`、`ArchivedCalendarEventDetailView`）は共通のコンポーネントを使用し、統一された構造を持つ。

#### 11.5.2 共通構成要素
1. **ヘッダー** (`DetailHeaderView`): タイトル、日時情報（開始/終了時刻、全日イベントの場合は日付のみ）
2. **説明セクション** (`DetailDescriptionSection`): 本文（タグ除去済み）、タグ一覧、URL自動リンク化
3. **メタ情報** (`DetailMetadataSection`): カレンダー名、同期状態、最終同期日時、追加情報（アーカイブイベントの場合）
4. **関連メモリー** (`RelatedMemoriesSection`): 過去と未来の関連エントリー
5. **ツールバー**: 統一された編集ボタン（「編集」テキスト付き、カラーボタン）

#### 11.5.3 メタ情報の表示
- **カレンダー名**: カレンダー所属を色ドットとカレンダー名で表示
- **同期状態**:
  - 同期済み: 「最終同期: YYYY/MM/DD HH:mm」形式で表示
    - カレンダーイベント: `cachedAt`（同期実行時刻）を表示
    - ジャーナル: 暫定として`updatedAt`を表示（将来的に同期実行時刻フィールド追加予定）
  - 同期待ち: オレンジの感嘆符アイコンと「同期待ち」テキスト
  - 未同期: グレーの円形アイコンと「未同期」テキスト
- **追加情報** (アーカイブイベントのみ):
  - ステータス（confirmed/cancelled等）
  - キャッシュ日時（`cachedAt`）
  - ジャーナル連携状態（連携済みの場合）
  - 祝日ID（祝日の場合）

#### 11.5.4 競合状態の表示（ジャーナルのみ）
- 競合が検出された場合、メタ情報セクションの前にオレンジの警告ボタンを表示
- 「競合を解決」ボタンをタップで`ConflictResolutionView`を表示

#### 11.5.5 URL自動リンク化
- https:// または http:// で始まるURLを自動検出してタップ可能なリンクに変換
- NSDataDetectorを使用した安定したURL検出
- タップでSafariが開く
- 複数URL対応、末尾の句読点を除外

### 11.6 開発者向けツール画面（DeveloperToolsView）

#### 11.6.1 アクセス方法
- 設定画面のバージョン情報を7回タップ
- 開発者モードが有効化され、設定画面に「開発者向けツール」セクションが表示される

#### 11.6.2 機能
- **同期ログ一覧**: 全ての同期操作のログを新しい順に表示
  - syncType（同期種別）、日時、カレンダーIDハッシュ、結果カウント
  - エラー、410フォールバック、429リトライのインジケーター
- **ログ詳細**: ログをタップで詳細モーダル表示
  - 基本情報（同期種別、開始/終了時刻、所要時間、カレンダーIDハッシュ）
  - 結果（更新/削除/スキップ/競合カウント、HTTPステータスコード）
  - フラグ（410フォールバック、429リトライ）
  - エラー情報（エラー種別、メッセージ）
- **JSON出力**: ログをクリップボードにコピー（デバッグ用）
- **ログ削除**: 全てのログを削除（確認ダイアログあり）

#### 11.6.3 プライバシー保護
- ユーザーコンテンツ（タイトル、本文）は記録しない
- カレンダーIDはSHA256ハッシュの最初の8文字のみ保存
- 同期操作のメタデータのみ記録

---

## 12. UI/UX仕様

**注意**: データモデルの詳細は[3. データ設計（責務分離）](#3-データ設計責務分離)を参照。既存のモデル定義（`JournalEntry`、`CachedCalendarEvent`、`ArchivedCalendarEvent`等）は段階的な移行の参考として残す。

**注意**: 同期設計の詳細は[5. 同期設計（差分パイプライン）](#5-同期設計差分パイプライン)を参照。

---

**注意**: データモデルの詳細は[3. データ設計（責務分離）](#3-データ設計責務分離)を参照。

### 12.1 デザイン原則

- **シンプル**: 2タブ構成、必要最小限の要素
- **モードン**: iOS標準に準拠しつつ洗練されたデザイン
- **高速**: 入力から保存まで最短ステップ
- **文章が主役で、UIは邪魔をしないこと**

### 12.2 カラースキーマ

#### 12.2.1 ベースカラー（ライトモード）
本アプリは **初期リリースではライトモードのみをサポート** する。**ダークモード対応は未実装**（将来フェーズで検討予定）。

| 要素 | カラーコード | 備考 |
|------|-------------|------|
| 背景 | #FAFAFA | 純白を避け、長文閲覧時の疲労を軽減 |
| メインテキスト | #1F1F1F | 高コントラスト |
| サブテキスト | rgba(31,31,31,0.6) | 補足情報用 |
| セパレーター | rgba(0,0,0,0.08) | 目立たせない |

#### 12.2.2 カードの基本デザイン
**予定とジャーナルは完全に統一されたカードデザインを使用する**（視覚的な区別は行わない）。

カードの左側に4px幅のカラーバーを表示し、カレンダーの色を反映する。アイコンは非表示（視認性向上のため）。

- ジャーナルエントリ作成時: カラーパレットから選択可能
  - カラー: デフォルト: ミュートブルー #3B82F6（カラーバーとして表示）
- 予定表示時: 設定でカレンダーごとに選択したカラーをカラーバーとして表示
  - カラー: デフォルト: ミュートブルー #3B82F6

#### 12.2.3 アクセントカラー

| 要素 | カラーコード |
|------|-------------|
| アクセント | #4CAF50 |

使用箇所は以下に限定する。
- 新規作成ボタン（FAB）
- 選択中の日付
- トグルON状態
- リンク的テキスト

### 12.3 カレンダー別カラー・アイコン設定

#### 12.3.1 概要
Googleカレンダーごとに、ユーザーが表示色とアイコンを選択できる機能を提供する。
- 色はアプリ側で用意した **デフォルトカラーパレットから選択** する方式とする
- アイコンはアプリ側で用意した **アイコンパレットから選択** する方式とする
- 自由入力型のカラーピッカーやアイコン選択は提供しない
- 各カレンダーの設定は、設定画面の「表示するカレンダー」セクションでカレンダー名をタップして開くカレンダー設定画面（`CalendarSettingsView`）で行う
- Googleカレンダー側で設定されているカラーをデフォルトとして取得（`GoogleCalendarClient.colorIdToHex`）

#### 12.3.2 デフォルトカラーパレット
カラーパレットは**Googleカレンダーの標準色をベース**にしています（Google Calendar APIの標準24色から25色を選択）。

- 5x5グリッドレイアウトで表示（25色）
- 赤系、オレンジ・黄色系、緑系、シアン・青系、紫系、ピンク系、茶色・グレー系など、各色系統から選択
- Google Calendar APIの標準カラーパレットを参照: https://developers.google.com/calendar/api/v3/reference/colors

#### 12.3.3 タイムラインでのカラーとアイコンの扱い
- **カレンダー色はカラーバーとして表示する**
  - タイムライン一覧: カード左側に4px幅のカラーバーを表示（**アイコンは非表示**）
  - 詳細画面: ヘッダー部分に4px幅のカラーバーを表示（**アイコンは表示**）
- ジャーナルエントリのカラーは個別に選択可能（カラーパレットから選択）
  - `entry.colorHex`が空文字列やデフォルト値（`#3B82F6`）の場合、カレンダーの色を使用
- 予定のカラーは、カレンダー設定画面でカレンダーごとに選択したものを適用
- 同一色を複数カレンダーで選択可能とする
- **予定とジャーナルは視覚的に区別しない**（完全に統一されたカードデザイン）

**アイコン表示ルール**:
- タイムライン一覧: アイコンは非表示（視認性向上のため）
- 詳細画面: 設定したアイコンを表示（カレンダーごとの設定を反映）

#### 12.3.4 アイコンパレット
カレンダーごとに設定するアイコンは、以下のアイコンパレットから選択する。設定したアイコンは、**詳細画面でのみ表示**される（タイムライン一覧では非表示）。

| アイコン | 名称 | 想定用途 |
|---------|------|---------|
| 📝 | メモ | 一般的な記録 |
| 📅 | カレンダー | 予定・イベント |
| 💡 | アイデア | 思いつき・発想 |
| 🎯 | 目標 | 目標・タスク |
| ❤️ | 感情 | 感情・思い出 |
| 🍽️ | 食事 | 食事・料理 |
| 🏃 | 運動 | 運動・健康 |
| 📚 | 学習 | 勉強・読書 |
| 🎨 | 創作 | 創作活動 |
| 🎵 | 音楽 | 音楽・エンタメ |
| 🚗 | 移動 | 旅行・移動 |
| 💼 | 仕事 | 仕事・ビジネス |
| 🏠 | 家 | 家庭・プライベート |
| 🌟 | 星 | 特別な日 |
| （なし） | なし | アイコンを表示しない |

### 12.4 タイポグラフィ

#### 12.4.1 フォント設定

| 言語 | フォント | 用途 |
|------|---------|------|
| 日本語 | Noto Sans JP | すべての日本語テキスト |
| 英数字 | Inter | すべての英数字テキスト |

#### 12.4.2 フォントサイズ
- タイトル: 18pt（セミボールド）
- 本文: 16pt（レギュラー）
- サブテキスト（日時、場所など）: 14pt（レギュラー）
- キャプション: 12pt（レギュラー）

---

## 13. 技術仕様

### 13.1 技術スタック

| レイヤー | 技術 |
|----------|------|
| 言語 | Swift 5.9+ |
| UIフレームワーク | SwiftUI |
| データ永続化 | SwiftData |
| 認証 | Google Sign-In SDK |
| カレンダーAPI | Google Calendar API (REST) |
| 位置情報 | CoreLocation（未実装） |
| 写真 | PhotosUI (PhotosPicker)（未実装） |
| データ管理 | SwiftData（RawCalendarEvent / TimelineRowIndex / SearchIndex） |
| クラッシュレポート | Firebase Crashlytics（オプション） |

### 13.2 SwiftData設定

アプリはSwiftDataに厳密な並行性設定を使用：
- `SWIFT_APPROACHABLE_CONCURRENCY = YES`
- `SWIFT_DEFAULT_ACTOR_ISOLATION = MainActor`

すべてのデータベースモデルはアプリ起動時にモデルコンテナに登録される（`CaleNoteApp.swift:14-20`）。

### 13.3 Google Calendar API設定

- OAuth Client ID: `505927366776-2gu092vlu40cj9hg00b40rkdsm1m1vk7.apps.googleusercontent.com`
- 必要なスコープ: Calendar read/write
- OAuthコールバックはカスタムURLスキームで処理（Info.plistで設定）

### 13.4 非機能要件

**注意**: パフォーマンス要件の詳細は[2. 非機能要件（性能）](#2-非機能要件性能)を参照。

#### 13.4.1 セキュリティ
- Google認証トークンはKeychainに保存
- ローカルデータは端末内に保存

#### 13.4.2 プライバシー
- 位置情報は許可制（未実装）
- 写真アクセスは許可制（未実装）
- 分析データは収集しない
- Crashlytics送信時もプライバシー保護を徹底
  - ユーザーコンテンツ（タイトル、本文）は送信しない
  - カレンダーIDはハッシュ化（SHA256の最初8文字のみ）
  - 同期操作のメタデータのみ送信

### 13.5 制約・前提条件

#### 13.5.1 技術的制約
- iOS 17以上必須（SwiftData使用のため）
- Googleアカウント必須（カレンダー連携時）
- ネットワーク必須（カレンダー同期時）
- オフライン時はジャーナル機能のみ利用可（ローカルキャッシュの表示・編集）

#### 13.5.2 設計上の制約
- **CloudKit同期は実装しない**: Google Calendarが唯一の外部永続先である
- **サーバー同期は実装しない**: 双方向同期はGoogle Calendar API経由で直接実現
- **ダークモードは未実装**: 初期リリースではライトモードのみサポート

#### 13.5.3 同期に関する制約
- 同期レート制限: 5秒間隔（`SyncRateLimiter`）
- 同期範囲: デフォルト過去30日〜未来30日（設定可能、最大365日）
- `syncToken`の有効期限: Google Calendar APIの仕様に依存（期限切れ時はフル同期にフォールバック）
- 競合処理: 30秒以上の差がある場合に競合検知、ユーザーに解決UIを表示（`ConflictResolutionView`）

---

## 14. 実装状況

### 14.1 Phase 1: MVP ✅ 完了
**目標**: 基本的なジャーナル機能が動作する

- [x] プロジェクトセットアップ
- [x] SwiftDataモデル定義
- [x] メイン画面（タイムライン表示）
- [x] ジャーナル作成/編集画面
- [ ] カレンダーシート（日付選択、記録日ドット表示） - **未実装**
- [x] 基本的な検索機能
- [x] ハッシュタグ抽出（本文から `#tag` をパース）
- [x] 手入力検索（`#tag` 形式でタグ検索）
- [x] 最近使ったタグのローカル表示（`TagStats`）
- [x] 設定画面（基本項目）
- [x] 初期オンボーディングフロー（`GoogleSignInOnboardingView`、`CalendarSelectionOnboardingView`、`OnboardingCoordinatorView`）

### 14.2 Phase 2: Googleカレンダー連携 ✅ 完了
**目標**: カレンダーの予定を表示できる

- [x] Google Sign-In実装（`GoogleAuthService`）
- [x] Calendar API連携（`GoogleCalendarClient`）
- [x] 予定の取得・表示（同期範囲: 過去30日〜未来30日、設定可能）
- [x] 差分同期の実装（`syncToken`使用、`CalendarSyncService`）
- [x] 予定とジャーナルの統合タイムライン（`TimelineItem`）
- [x] 同期範囲内イベントからのタグ抽出（`TagExtractor`）
- [x] Google Calendar への保存（`JournalCalendarSyncService`、`extendedProperties.private`使用）
- [x] 双方向同期（`CalendarToJournalSyncService`）
- [x] 拡張レンジ同期（`ArchiveSyncService`）

### 14.3 Phase 3: 拡張機能 ✅ 完了
**目標**: 使いやすさ向上

- [x] カラー・アイコン選択機能（カラーパレット・アイコンパレット実装）
- [x] 関連するエントリー機能（過去・未来の同日/同週同曜/同祝日エントリーの表示）
- [ ] 場所情報の追加（デフォルト設定含む） - **未実装**

### 14.4 Phase 4: 公開準備 🔄 進行中
**目標**: App Store申請

- [ ] アプリアイコン・スクリーンショット
- [ ] プライバシーポリシー作成
- [ ] App Store Connect設定
- [ ] TestFlight配布
- [ ] 審査申請

### 14.5 Phase 5: 開発者向けツール ✅ 完了
**目標**: デバッグと問題解決の効率化

- [x] 競合検知UI（`ConflictResolutionView`）
- [x] 競合解決機能（useLocal/useRemote）
- [x] 拡張レンジ同期のキャンセル機能
- [x] 開発者向けツール画面（`DeveloperToolsView`）
- [x] 同期ログ記録（`SyncLog`モデル）
- [x] 隠し開発者モード（7回タップで有効化）
- [x] 同期失敗のCrashlytics送信（`SyncErrorReporter`）

### 14.6 Phase 6: パフォーマンス最適化 🔄 進行中
**目標**: データ設計の3系統分離とインデックス最適化

- [ ] Raw Event Storeの統合実装
- [ ] Timeline UI Indexの実装（SwiftDataモデル化）
- [ ] Search Indexの実装（トークン化・逆引き）
- [ ] 差分適用パイプラインの実装
- [ ] State Storeの分離実装
- [ ] 段階検索の実装
- [ ] ローカル即反映の実装

### 14.7 Phase 7: 将来の拡張（公開後）
- [ ] ウィジェット対応
- [ ] カレンダーシート（日付選択、記録日ドット表示）
- [ ] ダークモード対応
- [ ] iPad対応
- [ ] 場所情報の追加（デフォルト設定含む）

**注意**: CloudKit同期は**実装予定なし**。Google Calendarが唯一の外部永続先である。

---

## 15. 障害・復旧方針

* **syncToken期限切れ（410）**: 該当カレンダーのみフル同期へフォールバックし、Indexを再構築する。
* **データ破損**: Timeline UI Index / Search Index は破棄して再構築できる。Raw Storeが基盤である。
* **大量更新**: 差分反映をバッチ化し、UI更新はまとめて適用する（小刻み更新でレンダリングを荒らさない）。

---

## 16. 実装ガイド（仕様からの拘束事項）

この設計を守るために、実装上の禁止事項を明文化する。

### 16.1 タイムライン画面での禁止事項

タイムライン画面で、Raw Storeや複数モデルを直接フェッチして「毎回ソート」「毎回グルーピング」してはならない。検索でRaw Storeを全文走査してはならない。同期完了時に全Indexを毎回作り直してはならない。やるなら差分のみ。

**禁止される実装パターン**:
```swift
// ❌ 禁止: Raw Storeを直接フェッチしてソート
let events = try modelContext.fetch(FetchDescriptor<RawCalendarEvent>())
let sorted = events.sorted { $0.start < $1.start }

// ❌ 禁止: 複数モデルを結合して表示
let journals = try modelContext.fetch(FetchDescriptor<JournalEntry>())
let events = try modelContext.fetch(FetchDescriptor<RawCalendarEvent>())
let merged = journals + events

// ❌ 禁止: 同期完了時に全Indexを再構築
func syncCompleted() {
    rebuildAllTimelineIndex() // 全件再構築は禁止
}
```

**推奨される実装パターン**:
```swift
// ✅ 推奨: Timeline UI Indexから直接取得（ソート済み）
let rows = try modelContext.fetch(
    FetchDescriptor<TimelineRowIndex>(
        predicate: #Predicate { $0.dateKey >= todayKey },
        sortBy: [SortDescriptor(\.sortKeyPrimary, order: .reverse),
                 SortDescriptor(\.sortKeySecondary, order: .reverse)]
    )
)

// ✅ 推奨: 差分のみ更新
func applySyncDiff(added: [Event], updated: [Event], deleted: [EventId]) {
    updateTimelineIndex(added: added, updated: updated, deleted: deleted)
    updateSearchIndex(added: added, updated: updated, deleted: deleted)
}
```

### 16.2 検索での禁止事項

検索でRaw Storeを全文走査してはならない。検索結果の表示は Timeline UI Index の rowId を参照して行う。

**禁止される実装パターン**:
```swift
// ❌ 禁止: Raw Storeを全文走査
func search(query: String) -> [Event] {
    let allEvents = try modelContext.fetch(FetchDescriptor<RawCalendarEvent>())
    return allEvents.filter { event in
        event.title.contains(query) || event.desc?.contains(query) ?? false
    }
}
```

**推奨される実装パターン**:
```swift
// ✅ 推奨: Search Indexから高速取得
func search(query: String) -> [TimelineRowId] {
    let tokens = tokenize(query)
    let rowIds = searchIndex.lookup(tokens: tokens)
    return rowIds
}

// ✅ 推奨: 検索結果はTimeline UI Indexを参照（ソート済み）
func displaySearchResults(rowIds: [TimelineRowId]) {
    let rows = try modelContext.fetch(
        FetchDescriptor<TimelineRowIndex>(
            predicate: #Predicate { rowIds.contains($0.id) },
            sortBy: [SortDescriptor(\.sortKeyPrimary, order: .reverse),
                     SortDescriptor(\.sortKeySecondary, order: .reverse)]
        )
    )
    // 表示
}
```

### 16.3 同期での禁止事項

同期完了時に全Indexを毎回作り直してはならない。やるなら差分のみ。

**禁止される実装パターン**:
```swift
// ❌ 禁止: 同期完了時に全Indexを再構築
func syncCompleted() {
    clearAllIndexes()
    rebuildAllIndexes() // 全件再構築は禁止
}
```

**推奨される実装パターン**:
```swift
// ✅ 推奨: 差分のみ適用
func applySyncResult(result: SyncResult) {
    // Raw Storeを更新
    updateRawStore(added: result.added, updated: result.updated, deleted: result.deleted)
    
    // Indexを差分更新
    updateTimelineIndex(
        added: result.added.map { toTimelineRow($0) },
        updated: result.updated.map { toTimelineRow($0) },
        deleted: result.deleted
    )
    updateSearchIndex(
        added: result.added.map { toSearchTokens($0) },
        updated: result.updated.map { toSearchTokens($0) },
        deleted: result.deleted
    )
}
```

---

## 17. 用語集

| 用語 | 説明 |
|------|------|
| エントリー | タイムライン上に表示可能な単位。ローカル作成エントリーとGoogle由来エントリーの2種があるが、UIでは区別しない |
| Raw Event Store | 同期の正規化ストア。Google Calendar APIのイベントをカレンダーID + イベントIDで一意に保持。UIは直接参照しない |
| Timeline UI Index | タイムライン描画のための"行"テーブル（永続）。UIが参照するのはこれのみ。Raw Storeから生成され、差分で更新される |
| Timeline View Window | 画面が現在保持している行IDの範囲（非永続、メモリ管理用）。破棄対象はView Windowのみで、Indexは削除しない |
| Search Index | 検索専用インデックス。タイトル・タグ・本文スニペットをトークン化し、逆引きできる構造で保持 |
| State Store | アプリの動作状態（同期状態、同期待ちキュー、競合フラグ、取得済みレンジ集合、syncToken等）を管理する軽量ストア |
| ローカル作成エントリー | アプリで作成されたジャーナル。作成時にGoogle Calendarイベントへ射影される |
| Google由来エントリー | Google Calendarから取得したイベント。必要に応じてジャーナル化（リンク）できる |
| タグ | ハッシュタグ形式のラベル（#仕事、#アイデア等） |
| syncToken | Google Calendar APIの差分同期用トークン |
| extendedProperties.private | Google Calendar Eventの拡張プロパティ。`journalId`を保存 |
| Single Source of Truth | Google Calendarが唯一の真実のソースである設計原則 |
| SyncErrorReporter | 同期失敗をCrashlyticsに送信するユーティリティ |
| SyncLog | 開発者向け同期ログモデル（SwiftData） |
| 取得済みレンジ | State Storeに保持される、月単位チャンク（例: "2024-01"）の集合。Asia/Tokyoの月で定義し、その月の00:00 JST ～ 翌月00:00 JSTをUTC変換してAPIに投げる。レンジ完走時に記録し、再実行を避ける |
| rowId | TimelineRowIndexの主キー。`base64url(calendarId) + ":" + base64url(eventId)`形式の安定ID |
| sortKeyPrimary | TimelineRowIndexのソートキー（主）。開始日時（UTCエポックミリ秒、Int64） |
| sortKeySecondary | TimelineRowIndexのソートキー（副）。eventIdの安定ハッシュ値（UInt64）。文字列比較を避ける |
| dateKey | ローカルTZ基準（Asia/Tokyo固定）のYYYYMMDD形式整数。セクション分けと日付検索に使用 |
| TagIndex | タグ検索用インデックス。`tag`（#を含む）→ `rowIds`配列（上限2000件） |
| PrefixTitleIndex | タイトル検索用インデックス。`prefix`（先頭1〜3文字）→ `rowIds`配列（上限2000件） |
| RelatedKeyIndex | 関連エントリー検索用インデックス。`key`（"monthDay:1223"等）→ `rowIds`配列（上限2000件） |

---

**この仕様書は製品版設計書（パフォーマンス最適化版）です。実装はこの設計に基づいて段階的に進められます。**

