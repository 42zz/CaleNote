# CaleNote iOSアプリ 仕様要件定義書

## 1. プロダクト概要

CaleNoteは、Googleカレンダーを唯一の正（Single Source of Truth）とし、予定と記録を同一のスケジュール体験として扱うiOSアプリである。本アプリの目的は、ユーザーが日常的に行っている「カレンダーを見る」という行為の流れを断ち切ることなく、そのまま記録を書く行為へ自然に接続することにある。

一般的なジャーナルアプリが要求する「専用アプリを開く」「書くための意識的な切り替え」を排除し、カレンダーという既存の習慣に寄生することで、継続性を獲得することを設計思想の中核とする。

CaleNoteにおいて、予定と記録はユーザー体験上は区別されない。すべては単一の「スケジュールエントリー」として扱われ、Googleカレンダー上のイベントとして保存・同期される。

## 2. 基本設計原則

本アプリの設計は、以下の原則に基づく。

* GoogleカレンダーをSSoTとする完全な双方向同期
* 操作に対する即時UI反映（ローカル即反映・非同期同期）
* Rawデータ走査を避けたインデックス駆動設計
* 学習コストを発生させないUI・操作導線

**加えて、本プロジェクトはAIエージェントを実装主体として利用する前提で設計・実装を行う。**
そのため、ビルド・実行・デバッグ・状態確認はすべて「機械が誤解しない形」で明示化されていなければならない。

## 3. 開発ワークフロー設計

### 3.1 Makefileによるビルド標準化

本プロジェクトでは、Xcode UI操作を正とせず、**Makefileに定義されたコマンドのみを正式なビルド手段**とする。

目的は以下の通り。

* エージェントが誤ったビルドコマンドを生成することを防ぐ
* ビルド成功／失敗を曖昧にしない
* CI・ローカル・エージェント実行の差異を排除する

最低限、以下のターゲットを持つことを必須とする。

* `make` : ビルドおよび実行
* `make build` : ビルドのみ
* `make test` : テスト実行

Xcode上での成功表示は参考情報であり、**Makefile経由での終了コードのみを信頼する。**

### 3.2 ビルド失敗の明確化（xcbeautify / pipefail）

エージェントは大量ログの中からエラーを正確に抽出できないことがあるため、以下を必須とする。

* `set -o pipefail` を使用し、パイプ処理時も失敗を正しく伝播させる
* `xcbeautify` を用いてビルドログを要約し、エラー箇所（ファイル・行・内容）を明示する

これにより「ビルドは成功した」とエージェントが誤認する状態を構造的に排除する。

### 3.3 UI可視化とアクセシビリティIDの必須化

エージェントはUIを直接視認できないため、**UI要素には原則としてアクセシビリティIDを付与する。**

特に以下の要素は必須対象とする。

* タイムラインの各エントリーセル
* FAB（新規作成ボタン）
* 保存・再同期・エラー表示に関わるUI

将来的に以下のツール連携を想定する。

* スクリーンショット取得・解析
* アクセシビリティAPI経由のUI操作
* UI構造のJSON化

UIは「人が見るもの」であると同時に、「エージェントが解析するデータ構造」であることを前提に設計する。

### 3.4 デバッグスナップショット機構

アプリ内部状態を外部から確認できるよう、**Debug Snapshot機構**を持つ。

以下の情報を、ユーザー操作またはデバッグUIからファイル出力可能とする。

* 現在表示中のスケジュールエントリーID一覧
* 各エントリーの startAt / endAt / syncStatus
* インデックス状態（Search / Related）
* 必要に応じてスクリーンショット（PNG）

出力形式はJSONおよび画像とし、Finder等から直接参照可能とする。

目的は、エージェントが「今アプリがどういう状態か」を推測ではなく**ファイルとして確認できるようにすること**である。

### 3.5 パフォーマンス検証の前提化

エージェントはアルゴリズム効率を誤る可能性があるため、**パフォーマンス問題は計測結果を正とする。**

* Instruments（Time Profiler）を用いた計測結果を根拠とする
* メインスレッドブロック、O(n²)以上の処理は原則禁止
* 問題箇所はスタックトレースとして共有可能な形で保存する

「遅い気がする」という感覚的判断は採用しない。

## 4. データモデル設計

### 4.1 スケジュールエントリー

CaleNoteにおける最小データ単位は「スケジュールエントリー」とする。スケジュールエントリーは、ユーザー体験上は単一の概念として扱い、予定か記録かといった種別をユーザーに認識させない。

一方で、同期処理・編集可否・検索・インデックス管理を正確に行うため、内部的には以下の管理情報を保持する。

* source（google / calenote）
* managedByCaleNote（boolean）
* googleEventId
* startAt / endAt
* title / body
* tags
* syncStatus（synced / pending / failed）
* lastSyncedAt

### 4.2 Googleカレンダーイベント対応

すべてのスケジュールエントリーは、Googleカレンダー上のイベントと1対1に対応する。CaleNoteで作成された記録は、Googleカレンダーイベントとして保存される際に、CaleNote管理イベントであることを示す識別メタデータを付与する。

ローカルデータはキャッシュおよび高速表示のための存在であり、最終的な正は常にGoogleカレンダーに置かれる。

### 4.3 データモデル実装原則

各モデルは以下の原則を守る。

* 同期・検索・表示は責務分離する
* デバッグスナップショットでシリアライズ可能であること
* インデックス更新は副作用を持たず、再生成可能であること

## 5. メイン画面（タイムライン）

メイン画面はGoogleカレンダーアプリのスケジュールビューをベンチマークとした縦方向タイムラインで構成される。

日付ごとにセクションを分け、各セクション内にその日のスケジュールエントリーを時系列順に表示する。Googleカレンダー由来の予定と、CaleNoteで作成された記録は同一のリスト上に混在して表示される。

同期未完了のエントリーには、状態を示すバッジを表示し、ユーザーが認識・回収可能な導線を用意する。

## 6. エントリー作成・編集

画面右下に配置されたFAB（＋）から、新規スケジュールエントリーを作成する。FAB操作時点で、対象日付は現在フォーカス中の日付として確定する。

入力項目は以下とする。

* タイトル
* 本文（任意）
* タグ（#tag形式）

保存時は、ローカルデータベースへの即時保存とUI更新を行い、その後バックグラウンドでGoogleカレンダーへ同期する。ネットワークエラー等により同期に失敗した場合でも、ローカル状態は保持され、後続の再同期処理で回収される。

## 7. 同期設計

同期はGoogleカレンダーを唯一の正とするが、ユーザー体験上は即時反映を優先する。

* アプリ操作時はローカルへ即時反映
* Googleカレンダーへの反映は非同期で実行

Googleカレンダー側での追加・編集・削除は、定期ポーリングおよびイベント検知によりアプリ側へ反映される。

各エントリーは同期状態を持ち、同期待ち・失敗状態はタイムラインおよび設定画面から再送可能とする。

同期処理はブラックボックス化せず、**状態が観測可能であること**を必須とする。

* 各エントリーは syncStatus を持つ
* pending / failed 状態はUIおよびDebug Snapshotで確認可能
* 再同期操作は明示的にトリガー可能

## 8. 検索機能

検索は専用のSearch Indexを用いて行い、Rawデータの全走査は行わない。タイトルの前方一致およびタグ検索は200ms以内のレスポンスを必須要件とする。

本文検索は段階的・遅延実行とし、初期検索結果には含めない。

## 9. 振り返り（関連エントリー）

エントリー詳細画面では、関連する過去・未来のエントリーを表示する。関連判定は以下の軸を用いる。

* 同一月日（MMDD一致）
* 同一週の同一曜日
* 同一祝日

関連エントリー取得は、専用のRelated Indexを使用し、Raw検索は行わない。取得されたID集合は、タイムラインインデックス経由で表示する。

## 10. UI・ナビゲーション構造

UI構造はGoogleカレンダーアプリの操作感をベンチマークとする。

上部には表示切替トグル、月表示、検索、今日フォーカスを配置する。左側にはサイドバーを設け、カレンダー表示切替、設定、フィードバック導線を提供する。

ユーザーに新たな概念を学習させないことを、UI設計上の制約条件とする。

## 11. 非機能要件

* 起動から初期表示まで体感1秒以内
* スクロール・検索時のフレーム落ちを許容しない
* ローカルデータ破損時はGoogleカレンダーから再構築可能
* **エージェントが状態を誤認しない設計であること**
